// Meta
:system-name: ShareShop
// Dokumenten
:doctype: book
:sectnums:
:lang: DE
:experimental:
// Assets
:imageDir: images/
// Inhaltsverzeichnis
:toc:
:toclevels: 2
:toc-title: Inhaltsverzeichnis


= {system-name}: Reflexion
{docdate}

= Gruppenreflexion - ShareShop

== Grober Überblick

Im SE2-Projekt *ShareShop* haben wir als Team aus 7 Personen, darunter 2 neue Teammitglieder, gearbeitet. Wir haben in 4 Sprints à 3 Wochen gearbeitet.

Als technische Basis haben wir *Vue* im Frontend sowie *FastAPI* und *SQLAlchemy* im Backend benutzt. Für Aufgabenverwaltung haben wir *GitHub Projects* benutzt. Die Themen und Diskussionspunkte für Meetings wurden vorab im *Miro* gesammelt.

Zur Qualitätssicherung gab es eine Definition of Done für Product Backlog Items (PBI):

- Alle Sub-Issues (Tasks oder Akzeptanzkriterien) sind abgeschlossen.
- Arbeit ist ins Remote Repository aufgenommen.
- PBI wurde im wöchentlichen Meeting besprochen.

Auf ein Kriterium für Code-Qualität (z.B. Linting, Tests) sind wir erst im Laufe des Semesters eingegangen und haben bewusst darauf verzichtet, um den Fokus auf Feature-Umsetzung zu legen.

Prüfungen erfolgten vor allem manuell. Im Laufe des Semesters haben wir aber Coding Standards eingeführt (Linter, Styleguidelines) und Tests begonnen (automatische Tests sowie Tests mit gemockten Daten).

== Top 3 Erfolge

=== Erfolg 1: Technische Schulden gezielt reduziert und Weiterentwicklung wieder möglich gemacht

*Welche Aufgaben wurden gut gelöst?*

Ein wesentlicher Erfolg war, dass wir technische Schulden aus vorherigen Entwicklungsphasen gezielt reduziert haben. Vorher war der Code im Frontend teilweise unübersichtlich, es gab doppelte Logik und große Dateien ohne klare Struktur. Das führte dazu, dass Teammitglieder viel Zeit für die Einarbeitung in den Code benötigten und einzelne Features, insbesondere das Favoriten-Feature, deutlich länger dauerten als erwartet.

*Wie wurde dieser Erfolg realisiert?*

Wir haben erkannt, dass Feature-Entwicklung ohne Stabilisierung der Codebasis langfristig zu noch mehr Problemen führt. Daher wurden 2–3 Verantwortliche bestimmt, die gezielt aufräumende Arbeiten übernahmen:  
- Frontend-Code wurde stärker in Komponenten ausgelagert (mehr Wiederverwendbarkeit).  
- Redundanter oder sinnloser Code wurde entfernt (z.B. doppelt definierte CSS-Regeln, wenn global bereits festgelegt).
- Für bestimmte Features wurden notwendige Datenbankanpassungen vorbereitet, damit darauf aufbauende Entwicklung möglich wurde.

Wichtig war dabei, dass die technischen Schulden priorisiert wurden, aber nicht in dem Umfang, alles komplett neu zu bauen. Stattdessen wurden die Teile überarbeitet, die die Weiterentwicklung konkret blockierten.

*Was wurde gelernt (Konzepte/Praktiken)?*

- Technische Schulden sichtbar machen und gezielt abbauen
- Refactoring zur Verbesserung von Wartbarkeit und Verständlichkeit  
- Aufgabenverantwortung für Aufräumarbeiten festlegen

*Wirkung:*

Nach dieser Aufräumphase war die notwendige Einlesezeit in den Code geringer und die Entwicklung wurde spürbar effizienter. Dadurch konnten wir blockierte bzw. aufgeschobene Features umsetzen: Das Favoriten-Feature wurde anschließend möglich, und auch das Einkaufsarchiv ließ sich einfacher implementieren.

=== Erfolg 2: Schnelles und erfolgreiches einarbeiten von zwei neuen Teammitgliedern

*Welche Aufgaben wurden gut gelöst?*

Zu Semesterbeginn kamen zwei neue Personen ins Team. Wir haben es geschafft, sie schnell einzubinden und "produktiv" zu machen, ohne dass der Prozess nachhaltig ins Stocken geriet.

*Wie wurde dieser Erfolg realisiert?*

Das Einarbeiten wurde durch mehrere Faktoren unterstützt:  
- Neue Teammitglieder erhielten zunächst kleinere Aufgaben, wurden aber relativ schnell auch an anspruchsvollere Aufgaben herangeführt, sobald es realistisch erschien.
- Einzelne Teammitglieder nahmen sich aktiv Zeit, um Projektaufbau, Code und Workflow zu erklären.
- Es gab bereits eine Git-Workflow-Anleitung, die viele typische Einstiegshürden (Branching und Umgang mit Änderungen) reduzierte.
- Die neuen Teammitglieder brachten sich zusätzlich selbständig ein, stellten Fragen und lieferten eigene Ideen.

*Was wurde gelernt (Konzepte/Praktiken)?*

- Wissensmanagement (Doku + direkte Einführung)  
- Schrittweises Heranführen über passende Task-Zuschnitte  
- Teamkultur als Produktivitätsfaktor

*Wirkung:*

Bereits nach etwa einer Woche konnten die neuen Teammitglieder produktiv beitragen, was auch dadurch begünstigt wurde, dass das Projekt zu diesem Zeitpunkt noch relativ überschaubar war. Besonders positiv war, dass sie früh eigene Ideen einbgeracht haben und das Team eine offene Einstellung hatte, in der sämtliche Ideen und verbesserungsvorschläge willkommen waren.

=== Erfolg 3: Flache Hierarchie und konstruktive Entscheidungsprozesse bei Produktfragen

*Welche Aufgaben wurden gut gelöst?*

Ein dritter Erfolg war die Teamkultur: Entscheidungen wurden in der Regel demokratisch getroffen und Meinungsverschiedenheiten offen angesprochen. Das half besonders bei anspruchsvolleren Produktfragen, bei denen es mehrere plausible Varianten gab.

*Wie wurde dieser Erfolg realisiert?*

Obwohl der PO formal das letzte Wort hat, wurden Entscheidungen nicht von oben getroffen. Stattdessen wurden die Einschätzungen der Entwickler:innen aktiv eingeholt, insbesondere zu Umsetzbarkeit und Aufwand. Da die Entwickler:innen auch gleichzeitig Stakeholder der Zielgruppe waren, wurden Diskussionen nicht nur fachlich sondern auch nutzerorientiert geführt.

Ein konkretes Beispiel ist die Kostenaufteilung. Es gab mehrere mögliche Berechnungsmodelle und Umsetzungsmöglichkeiten. Hier wurde vom PO zusammen mit den Entwickler:innen eine gemeinsame Auswahl getroffen (realistisch für Nutzer:innen und gleichzeitig umsetzbar).

*Was wurde gelernt (Konzepte/Praktiken)?*

- Gemeinsames Verständnis über Anforderungen 
- Abwägung des Mehrwerts für den Nutzer und technischer Realisierbarkeit
- Konfliktlösung durch direkte Kommunikation und Teamentscheidung

*Wirkung:*

Diese Arbeitsweise verhinderte längere Konflikte, reduzierte Missverständnisse und führte zu sinnvollen Entscheidungen. Teammitglieder fühlten sich sicher, Vorschläge einzubringen, ohne Angst vor negativen Reaktionen.

== Top 3 Misserfolge

=== Misserfolg 1: Coding Standards und Tests wurden relativ spät eingeführt und blieben ohne Automatisierung

*Was ist besonders schlecht gelaufen?*

Coding Standards (Linter, Styleguidelines) und Tests wurden erst zur Mitte des Semesters eingeführt. Davor entstand inkonsistenter Code, und Prüfungen mussten überwiegend manuell erfolgen. Ohne automatisierte Checks war die Durchsetzung der Standards abhängig von der Disziplin und Aufmerksamkeit des Teams.

*Gründe (Wie kam es dazu?):*

- Die Relevanz und konkrete Ausgestaltung dieser Themen wurde in der Lehrveranstaltung/Praktika erst relativ spät behandelt, wodurch das Thema auch im Projekt später priorisiert wurde.  
- Zu Beginn lag der Fokus stärker auf Feature-Umsetzung; Altlasten im Frontend haben zusätzlich Kapazitäten gefressen.
- Keine Tools, die Standards automatisch durchsetzen.

*Was hätte man tun können, um das Problem zu verhindern?*  

- Standards und eine minimale Teststrategie bereits im ersten Sprint festlegen (auch ohne den Impuls aus den Vorlesungen).  
- Definition of Done um Kriterien erweitern z.B. Linter läuft lokal, mindestens Basistests vorhanden.
- Automatisierte Prüfungen von Anfang an einführen, um menschliche Fehler zu vermeiden.

*Was hätten wir tun können, um das Problem zu verhindern?*

Als direkte Maßnahme würden wir GitHub Actions einführen, sodass nur Code gemerged wird, der zumindest buildbar/kompilierbar ist und grundlegende Checks besteht (Linting). Damit würden Qualitätsanforderungen verlässlich und unabhängig von manueller Kontrolle eingehalten werden.

=== Misserfolg 2: Unter-der-Woche-Kommunikation und frühes Einholen von Feedback war schwierig

*Was ist besonders schlecht gelaufen?*

Die Kommunikation und Abstimmung unter der Woche funktionierte nur eingeschränkt. Durch unterschiedliche Zeitpläne war es schwierig, sich außerhalb des wöchentlichen Meetings regelmäßig abzustimmen. Zwar funktionierten Abhängigkeiten wie z.B. die Datenbankänderungen insgesamt gut, aber bei einzelnen Themen litt die Qualität bzw. entstand Nacharbeit, weil Feedback zu spät kam.

Ein konkretes Beispiel war die Gestaltung von Wireframes. Entwicklermeinungen konnten häufig erst im Meeting eingeholt werden. Dadurch war gelegentlich bereits viel Arbeit in Ausarbeitungen geflossen, die anschließend verworfen wurden, weil eine Alternative aus dem Team besser erschien. Später fehlte Zeit, die Wireframes nachzuziehen mit dem Ergebnis, dass Wireframes und App nicht überall deckungsgleich sind.

*Gründe:*

- Stark asynchrone Zeitfenster; das gemeinsame Meeting musste sehr spät stattfinden (Sonntag 18:00), um alle überhaupt zusammenzubekommen.  
- Austausch unter der Woche war zwar über Whatsapp und Discord möglich, wurde aber nicht immer ausreichend genutzt, um frühes Feedback einzuholen.
- Manche Themen wie zum Beispiel das Design/UX profitieren stark von kurzen Feedbackschleifen, die hier erschwert waren.

*Was hätten wir tun können, um das Problem zu verhindern?*

- Frühere Feedback-Mechanismen einführen z.B. 48h Kommentarfenster auf Miro/Issues, klare Deadline für Feedback.  
- Kurze, optionale Umfragen bzw. schriftliche Entscheidungsrunden(z.B. Abstimmung in Discord).
- Designentscheidungen stärker als Entscheidungspunkte im Miro behandeln (Wireframe Review).

*Was würden wir jetzt tun?*

Wir würden für Design-/UX-Themen Feedbackprozesse einführen (Miro-Link + Deadline + kurze Entscheidungsdiskussion), damit Meinungen früh eingesammelt werden und nicht erst im Meeting zu spät kommen.

=== Misserfolg 3: Unsauberer Code verursachte Feature-Verschiebungen

*Was ist besonders schlecht gelaufen?*

Altlasten im Frontend (doppelter Code, fehlende klare Struktur, zu viel Logik in einzelnen Dateien) führten dazu, dass Features nicht wie geplant umgesetzt werden konnten. Das Favoriten-Feature musste nach hinten verschoben werden, weil zunächst strukturelle Umbauten nötig waren.

*Gründe:*

- Im Vorsemester wurde viel implementiert, aber nicht sauber strukturiert (Separation of Concerns, Wiederverwendbarkeit). 
- Ohne frühe Standards und Tests wuchsen die Inkonsistenzen schnell.  
- Technische Schulden waren erst spürbar, als komplexere Features integriert wurden.

*Was hätten wir tun können, um das Problem zu verhindern?*

- Frühzeitig auf Separation of Concerns und Wiederverwendbarkeit achten (Komponenten/Module)
- Technische Schulden kontinuierlich in kleinen Anteilen abbauen, statt erst wenn es ernsthafte Probleme gibt.
- Definition of Done und Styleguidelines früher ernster nehmen.

*Was würden wir jetzt tun?*

Wir würden bereits zu Beginn des Projekts stärker auf eine klare Struktur achten, also mehr kleinere Komponenten, doppelte Logik unterbinden und regelmäßig Refactoring-Zeit einplanen. Außerdem würden wir die im Semester erarbeiteten Styleguidelines konsequent von Anfang an anwenden.

== Fazit

Die Gruppenarbeit hat uns deutlich gezeigt, dass Entwicklung nicht nur von der Umsetzung der Features abhängt, sondern auch stark von Prozess- und Qualitätsentscheidungen. Besonders erfolgreich waren wir beim gezieltem Abbau technischer Schulden, bei einer klaren Einführung von neuen Gruppenmitgliedern oder bei offenen Entscheidungsprozessen. Gleichzeitig hatten wir dort Probleme, wo bei uns Struktur und Automatisierung zu spät umgesetzt wurde (Stichwort Code-Standards/Tests) und wo Kommunikation außerhalb des einzigen wöchentlichen Meetings nur schwer möglich war.

Für zukünftige Projekte würden wir frühe Qualitäts- und Kommunikationsmechanismen stärker priorisieren (GitHub-Actions, eine strengere Definition of Done, Feedback asynchron einholen), um Komplexität über mehrere Sprints besser managebar zu halten.


== Einzelreflexion

=== Maximilian Paul

<<<

=== Pierre Kißling

<<<

=== Marlene Fritz

<<<

=== Levin Heinrich

Ich war im Projekt hauptsächlich für die Implementierung des Backends zuständig. Dabei habe ich mich um die Datenbank gekümmert und die API_Endpunkte, sowie die ORMs für die verschiedenen Modelle erstellt. Zusätzliche habe ich jedoch auch Aufgaben im Frontend übernommen, wie zum Beispiel das Archiv-Feature, aber auch die Mitarbeit an der List- und Einkauf-Komponente.

==== Datenbank
===== Ausgangssituation
Zu Beginn ging es darum eine Struktur zu entwickeln, die es ermöglicht die verschiedenen Entitäten und deren Beziehnungen (die durch die Planung der APP entstanden sind) in einer Datenbank abbilden zu können. Im Laufe des Projekts musste diese Struktur dann angepasst oder um neue Tabellen ergänzt werden. Ich ordne diese Aufgabe in die Analyse- Entwurf- und Implementierungsphase ein.

===== Lösungsweg
Als die Datenbank erstellt bzw. erweiter werden musste begann ich mit einer grafischen Abbildung der Tabellen un deren Beziehungen. Sommit konnte ich mir einen Überblick über die geplante Struktur verschaffen und ggf. Fehler frühzeitig vor der Umsetzung erkennen. Zudem mussten die Werte, die gespeichert werden sollten, vorher klar im Zweck definiert werden, um eine Aussage über den Datentyp treffen zu können. Nachdem die Struktur stand, habe ich die Tabellen in MySQL erstellt und dort einmal getestet, um zu prüfen ob Foreign Keys und andere Einschränkungen wie NULL/NOT NULL richtig funktionierten.  

===== Bewertung und Lernerfahrungen
Rückblickend mkann ich sagen, dass mein Vorgehen grundätzlich gut funktioniert hat. Die grafische Abbildung (auch wenn es nur eine grobe Skizze war) hat besonders am Anfang beim verstehen geholfen. Nahezu am Ende des Projekts habe ich festgestellt dass ich mir jedoch Zeit hätte sparen können, wenn ich die Tabellen direkt in SQLAlchemy erstellt hätte. Da ich mich zu Beginn des Projekts noch nicht so gut mit dem ORM auskannte, habe ich mich für den "sicheren" Weg entschieden. Dies hat zwar funktioniert, aber im Nachhinein gesehen war es unnötig aufwendig.

==== API
===== Ausgangssituation
Bereitstellen der API-Endpunkte für das Frontend. Dabei ging es darum die verschiedenen Funktionalitäten, die im Frontend benötigt werden, über Endpunkte verfügbar zu machen. Ich ordne diese Aufgabe in die Implementierungs- und Testphase ein.

===== Lösungsweg
Da ich immer vorher die Datenbankstruktur erstellte, hatte ich bereits ein gutes Verständnis über die Entitäten und deren Beziehungen. Die Erstellung der ORMs in SQLAlchemy war somit relativ einfach. Anschließend habe ich die Endpunkte (read, create, update, delete) für die verschiedenen Modelle erstellt. Dabei stand ich meistens immer im Austausch mit der Person, die das Frontend dazu entwickelte, um sicherzustellen, dass die Endpunkte auch alle benötigten Funktionalitäten abdecken. Dabei musste ich auch immer überlegen, was man am besten im Backend erledigt und was im Frontend. Wenn ich die Endpunkte erstellt hatte, habe ich diese meist mit der Swagger-UI getestet (weil der Großteil der Arbeit im 1. Semester bzw. am Anfang vom 2. Semester stattfand). In den meisten Fällen mussten dann noch ein paar Anpassungen vorgenommen werden.

===== Bewertung und Lernerfahrungen
Was positiv war, die Kommunikation mit dem Frontend-Team. Diese Kommunikation war auch nötig, da mann sicherstellen musste, dass beide Seiten (Frontend/Backend) die gleichen Vorstellungen von der Funktionalität haben. Nachteilig war, dass ich mir am Anfang etwas unsicher war, welche Berechnungen/Konvertierungen/Validierungen im Backend oder im Frontend gemacht werde sollten. Das wurde mit der Zeit klarer und die Qualität der API-Endpunkte wurde somit auch besser.  

==== Archiv-Feature (Frontend)
===== Ausgangssituation
Das Archiv-Feature ermöglicht es dem Nutzer abgeschlossene Einkäufe, mit allesn Produkten die in diesem Einkauf eingekauft wurden,  im nachhinein anzusehen. Im Archiv kann man nach den einzelnen Listen filtern sowie nur Einkäufe anzeigen lassen die von mir selbst getätig wurden. Ich ordne diese Aufgabe in die Implementierungs- und Testphase ein.

===== Lösungsweg
Zuerst habe ich mir überlegt wie das UI ausehen soll und welche Funktionalitäten es bieten soll. Anschließend habe ich die API-Endpunkte erstellt, die benötigt werden. Danach habe ich das Frontend entwickelt. Das Ergebnis habe ich dann im Team vorgestellt und Feedback eingeholt. Da ich selbst als auch das Team mit dem Ergebnis mittelmäßig zufrieden waren haben wir uns im Review mit den anderen Projektgruppen ausgetauscht und ich habe mir Anregungen geholt, wie das Archiv verbessert werden könnte. Dort entstanden dann gute Ideen, die ich dann auch umgesetzt habe. Das Endergebnis wurde dann in der App getestet und vom gesamten Team als gut befunden.

===== Bewertung und Lernerfahrungen
Bei dieser Aufgabe wurde mir bewusst, wie wichtig Feedback ist, welches von Nutzern der App kommt. Diese kennen nämlich die Architektur hinter der App nicht und fokussieren sich lediglich auf die Anforderungen bzw. ihre Wünsche. Somit entstand nämlich eine Idee der Filterfunktion welche grundlegend einen anderen Ansatz verfolgte. Daraus resultierte ein Ergebnis, welches ich selbst aus Nutzersicht besser fand, aber aus Entwicklersicht garnicht so betrachtet hatte.


=== Erik Wenke

Im Rückblick auf den Verlauf des zweiten Teiles von Software Engineering
habe ich hauptsächlich an zwei Features/Anforderungen gearbeitet.
Einmal galt es, zusätzlich zur schon vorhandenen manuellen Installation,
eine weitere Deployment-Strategie mittels Docker zu entwickeln.
Zudem habe ich Zeit dafür investiert,
die UI für die Favoriten zu implementieren.
Die Favoriten kann man sich dabei als Templates für häufig gekaufte Produkte vorstellen.

==== Docker

Der zentrale Aufwand bei der Entwicklung der Strategie lag im Aneignen von Wissen.
Docker war für mich ein neues Tool.
Zudem hatten wir in der bisherigen Entwicklung wenige Gedanken im Hinblick auf
Deployment-Strategien investiert.
Um einen Einblick in Docker zu bekommen und meinen Lernprozess anzustoßen,
hatte sich gut das angebotene Praktikum geeignet.
Bei allen weiteren Fragen konnte mir die link:https://docs.docker.com/[Docker Dokumentation]
oder spezifische Anleitungen
(z.B. link:https://docs.docker.com/guides/vuejs/containerize/[Vue.js]) helfen.

Währender der Umsetzung ist uns aufgefallen,
dass wir bis jetzt die URL der von uns bereitgestellten API
direkt in den Frontendquelltext geschrieben haben.

[source,JavaScript]
----
const response = await axios.get(`http://141.56.137.83:8000/einheiten`);
----

Diese müssten bei einer Installation ausgetauscht werden,
wenn man die API und Datenbank selber hosten möchte.
Das Erstellen einer Axios Instanz mit einer Konfiguration,
welche die Basis URL als Umgebungsvariable bekommt,
löste das Problem.

Mit der Umgebungsvariable ensteht aber ein weiteres Problem.
Das Frontend-Building-Tool link:https://vite.dev/[Vite] benötigt die Umgebungsvariable
zur Build-Zeit.
Dies verhindert, dass man ein Docker Image erstellen kann,
welchem erst zur Laufzeit die Basis URL übergeben bekommt.
Da wir bis zum aktuellen Stand noch keine Lösung gefunden haben,
muss man sich das Docker Image selber compilieren,
auch wenn es "wahrscheinlich" eine Lösung gibt.

Die Beschreibung des Docker Images für die API hat ohne Zwischenfälle funktioniert.
Hier wurde nur hinzugefügt,
dass die mit der API verbundene Datenbank noch nicht verhandene,
aber in der SQLAlchemy MetaData beschriebene,
Tabellen direkt erstellen soll.
So muss das Datenmodell nicht zusätzlich durch ein SQL-Skript beschrieben werden.
Eine Beispiel-Installation der gesamten Anwendung auf einem System
ist über einem Docker Compose File realisiert.

Damit ergänzt die entwickelte Deployment-Strategie,
die manuelle Installation des Systems.
Auch wenn Sie aufgrund der momentanen Notwendigkeit die Docker Images selber zu bauen,
noch nicht diese abgelöst hat.
Im Rückblick freue ich mich darüber, die Möglichkeit bekommen zu haben,
mich mehr mit Docker auseinandersetzen zu können.
Ich würde behaupten, dass ich einen guten Einblick in Docker bekommen habe,
auch wenn mir im Moment noch ein bisschen der Überblick fehlt,
um die Gesamtheit und Sinnigkeit von Docker als Tool einzuschätzen.
Gerade in der Abtrennung von anderen Möglichkeiten wie z.B. link:https://nixos.org/[Nix]
fehlt mir noch ein bisschen die Übersicht,
um eine fundierte und disskursfähige Meinung zu entwickeln.
Auch stört es mich, dass bis jetzt keien Lösung für das Vite-Build-Problem gefunden wurde.

==== Favoriten

Bevor ich die UI implementierte, waren mir schon zwei Sachen im Kopf.
Erstens sollten die einzelnen Komponenten übersichtliche sein,
um zu verhindern, dass wir eine weitere Komponente erstellen,
welche 900+ Zeilen Quelltext beinhaltete (siehe List.vue).
Zudem war ein weiteres Ziel, bei der Erstellung des UI mehrere wieder verwendbare
Komponenten wie zum Beispiel Input Felder zu erstellen.

Die Herausforderung war,
dass je kleinteiliger ich die Komponenten voneinander trenne,
desto mehr Gedanken muss ich mir über die Kommunikation dieser miteinander machen.
Möchte ich zum Beispiel ein allgemeines SingleChoice-Feld erstellen,
dann muss sein interner Zustand abgekoppelt von dem der Elternkomponente sein.
So mussen Funktionalitäten wie Auswahlmöglichkeiten und Standardwert übergeben
und deren Veränderung kommuniziert werden.

Eine Lösung war die Favoriten über globales Prop-Drilling,
allen Kind Komponenten der App-Komponente als reaktive Variable zur Verfügung zu stellen.

[source,JavaScript]
----
// App.vue
const favorites = ref([]);
provide("favorites", favorites);

// Favorites.vue
inject("favorites");
----

Somit können alle Komponenten die Favoriten bearbeiten
und teilen einen gemeinsamen Zustand der Favoriten.

Neben den von mir entwickelten Input Feldern,
könnte ich auch auf bereits implementierte Komponenten zurückgreifen.
Die Komponente, welche die Produkte in den Einkauflisten als Karte darstellt,
konnte ich auch hier nutzen,
da auch die Favoriten als Gitter dargestellt werden sollten.

Abschießend sehe ich auf die Implementierung des UI eher kritisch.
Die von mir entwickelten allgemeinen Komponenten (NumInput, TextInput, SelectObjectArray)
wurden nicht nochmal an anderer Stelle eingebunden.
Der Grund dafür ist einfach. Es gibt Component-Libraries.
Diese hatten wir nicht von Anfang an bei der Entwicklung unseres UI bedacht.
Ein klassiches Ziel für ein zukünftiges umfangreiches Refactoring.
Generell würde ich bei einer Überarbeitung des gesamten Projektes gerne
weitere Frameworks und Tools einbinden
(z.B. link:https://nuxt.com/[Nuxt] oder link:https://tailwindcss.com/[Tailwind CSS]),
um Funktionalitäten aus- und zuverlagern.
Auch würde ich mich bei einer Überarbeitung für einen Store (z.B. link:https://pinia.vuejs.org/[Pinia])
anstatt des Prop-Drillings entscheiden,
um den Anwendungszustand zu verwalten.

Diese Verbesserungsmöglichkeiten sind jedoch nicht nur negativ zu sehen.
Durch verschiedene andere Module ist der Umfang meines/unseres Wissens
dieses Semester stark gestiegen und unterscheidet sich deutlich von dem,
was zum Anfang des Semesters vorhanden war.
Die Implementierung nur auf HTML, CSS und JavaScript
(im Rahmen des Vue Frameworks) aufzubauen,
würde ich schlussendlich als gute Erfahrung einschätzen.

<<<

=== Eric Hübel

<<<

=== Ahmad Alrmih

Im zweiten Teil von *Software Engineering 2* habe ich mich hauptsächlich mit der **Implementierung und Absicherung der Backend-Funktionalitäten** der ShareShop-Anwendung beschäftigt. Mein Schwerpunkt lag dabei auf der **Entwicklung von Unit-Tests**, der **Mitarbeit an API-Endpunkten** sowie der **Implementierung von Validierungslogik**.

==== Ausgangssituation und Einordnung in den SE-Prozess

Meine Aufgaben lassen sich vor allem den Phasen **Implementierung** und **Test** zuordnen.  
Konkret habe ich:
* an mehrere **FastAPI-Endpunkten** mitgearbeitet
* **Validierungsfunktionen** für Eingaben entwickelt
* eine **umfassende Suite von Unit-Tests** für die API erstellt

Die getesteten Endpunkte wurden teilweise oder größten teils  von anderen Teammitgliedern entworfen oder implementiert, sodass meine Arbeit direkt auf bestehenden Analyse- und Entwurfsentscheidungen aufbaute.

==== Lösungsweg

Für die Tests habe ich **pytest** in Kombination mit **unittest.mock** verwendet. Ziel war es, die Geschäftslogik der API **isoliert von der Datenbank** zu testen. Dazu habe ich:
* die SQLAlchemy-Session mit `@patch` gemockt
* `MagicMock` genutzt, um verschiedene Datenbank-Szenarien (Erfolg, „nicht gefunden“) zu simulieren
* Hilfsfunktionen erstellt, um Mock-Objekte für Nutzer, Produkte, Listen und weitere Modelle wiederverwendbar zu erzeugen

Die Tests folgen konsequent dem **Arrange–Act–Assert-Prinzip**, was die Lesbarkeit und Wartbarkeit verbessert.  
Zuvor habe ich Validierungsfunktionen entwickelt, um fehlerhafte Eingaben frühzeitig abzufangen und konsistentes Verhalten der Endpunkte sicherzustellen.

==== Bewertung und Lernerfahrungen

Meine Lösung hat gut funktioniert:  
Alle implementierten Tests nun laufen zuverlässig und decken sowohl Erfolgs- als auch Fehlerfälle ab. Dadurch konnten mehrere logische Fehler frühzeitig erkannt werden, ohne die Anwendung manuell testen zu müssen.

Besonders gelernt habe ich:
* wie wichtig **korrektes Mocking** komplexer Datenbank-Abfragen ist
* dass gut geschriebene Tests als **Dokumentation des erwarteten Verhaltens** dienen
* dass Validierung ein zentraler Bestandteil robuster API-Entwicklung ist

Rückblickend sehe ich meinen Beitrag als wertvoll für die **Qualitätssicherung** und **Wartbarkeit** des Projekts. Die enge Verzahnung meiner Arbeit mit den Implementierungen anderer Teammitglieder hat mir zudem geholfen, den gesamten Entwicklungsprozess besser zu verstehen.
