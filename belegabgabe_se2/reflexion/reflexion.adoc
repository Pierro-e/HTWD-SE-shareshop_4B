// Meta
:system-name: ShareShop
// Dokumenten
:doctype: book
:sectnums:
:lang: DE
:experimental:
// Assets
:imageDir: images/
// Inhaltsverzeichnis
:toc:
:toclevels: 2
:toc-title: Inhaltsverzeichnis


= {system-name}: Reflexion
{docdate}

== Gruppenreflexion

=== Misserfolge

==== 1. ...
==== 2. ...
==== 3. ...

=== Erfolge

==== 1. ...
==== 2. ...
==== 3. ...

== Einzelreflexion

=== Maximilian Paul

<<<

=== Pierre Kißling

<<<

=== Marlene Fritz

<<<

=== Levin Heinrich

Ich war im Projekt hauptsächlich für die Implementierung des Backends zuständig. Dabei habe ich mich um die Datenbank gekümmert und die API_Endpunkte, sowie die ORMs für die verschiedenen Modelle erstellt. Zusätzliche habe ich jedoch auch Aufgaben im Frontend übernommen, wie zum Beispiel das Archiv-Feature, aber auch die Mitarbeit an der List- und Einkauf-Komponente.

==== Datenbank
===== Ausgangssituation
Zu Beginn ging es darum eine Struktur zu entwickeln, die es ermöglicht die verschiedenen Entitäten und deren Beziehnungen (die durch die Planung der APP entstanden sind) in einer Datenbank abbilden zu können. Im Laufe des Projekts musste diese Struktur dann angepasst oder um neue Tabellen ergänzt werden. Ich ordne diese Aufgabe in die Analyse- Entwurf- und Implementierungsphase ein.

===== Lösungsweg
Als die Datenbank erstellt bzw. erweiter werden musste begann ich mit einer grafischen Abbildung der Tabellen un deren Beziehungen. Sommit konnte ich mir einen Überblick über die geplante Struktur verschaffen und ggf. Fehler frühzeitig vor der Umsetzung erkennen. Zudem mussten die Werte, die gespeichert werden sollten, vorher klar im Zweck definiert werden, um eine Aussage über den Datentyp treffen zu können. Nachdem die Struktur stand, habe ich die Tabellen in MySQL erstellt und dort einmal getestet, um zu prüfen ob Foreign Keys und andere Einschränkungen wie NULL/NOT NULL richtig funktionierten.  

===== Bewertung und Lernerfahrungen
Rückblickend mkann ich sagen, dass mein Vorgehen grundätzlich gut funktioniert hat. Die grafische Abbildung (auch wenn es nur eine grobe Skizze war) hat besonders am Anfang beim verstehen geholfen. Nahezu am Ende des Projekts habe ich festgestellt dass ich mir jedoch Zeit hätte sparen können, wenn ich die Tabellen direkt in SQLAlchemy erstellt hätte. Da ich mich zu Beginn des Projekts noch nicht so gut mit dem ORM auskannte, habe ich mich für den "sicheren" Weg entschieden. Dies hat zwar funktioniert, aber im Nachhinein gesehen war es unnötig aufwendig.

==== API
===== Ausgangssituation
Bereitstellen der API-Endpunkte für das Frontend. Dabei ging es darum die verschiedenen Funktionalitäten, die im Frontend benötigt werden, über Endpunkte verfügbar zu machen. Ich ordne diese Aufgabe in die Implementierungs- und Testphase ein.

===== Lösungsweg
Da ich immer vorher die Datenbankstruktur erstellte, hatte ich bereits ein gutes Verständnis über die Entitäten und deren Beziehungen. Die Erstellung der ORMs in SQLAlchemy war somit relativ einfach. Anschließend habe ich die Endpunkte (read, create, update, delete) für die verschiedenen Modelle erstellt. Dabei stand ich meistens immer im Austausch mit der Person, die das Frontend dazu entwickelte, um sicherzustellen, dass die Endpunkte auch alle benötigten Funktionalitäten abdecken. Dabei musste ich auch immer überlegen, was man am besten im Backend erledigt und was im Frontend. Wenn ich die Endpunkte erstellt hatte, habe ich diese meist mit der Swagger-UI getestet (weil der Großteil der Arbeit im 1. Semester bzw. am Anfang vom 2. Semester stattfand). In den meisten Fällen mussten dann noch ein paar Anpassungen vorgenommen werden.

===== Bewertung und Lernerfahrungen
Was positiv war, die Kommunikation mit dem Frontend-Team. Diese Kommunikation war auch nötig, da mann sicherstellen musste, dass beide Seiten (Frontend/Backend) die gleichen Vorstellungen von der Funktionalität haben. Nachteilig war, dass ich mir am Anfang etwas unsicher war, welche Berechnungen/Konvertierungen/Validierungen im Backend oder im Frontend gemacht werde sollten. Das wurde mit der Zeit klarer und die Qualität der API-Endpunkte wurde somit auch besser.  

==== Archiv-Feature (Frontend)
===== Ausgangssituation
Das Archiv-Feature ermöglicht es dem Nutzer abgeschlossene Einkäufe, mit allesn Produkten die in diesem Einkauf eingekauft wurden,  im nachhinein anzusehen. Im Archiv kann man nach den einzelnen Listen filtern sowie nur Einkäufe anzeigen lassen die von mir selbst getätig wurden. Ich ordne diese Aufgabe in die Implementierungs- und Testphase ein.

===== Lösungsweg
Zuerst habe ich mir überlegt wie das UI ausehen soll und welche Funktionalitäten es bieten soll. Anschließend habe ich die API-Endpunkte erstellt, die benötigt werden. Danach habe ich das Frontend entwickelt. Das Ergebnis habe ich dann im Team vorgestellt und Feedback eingeholt. Da ich selbst als auch das Team mit dem Ergebnis mittelmäßig zufrieden waren haben wir uns im Review mit den anderen Projektgruppen ausgetauscht und ich habe mir Anregungen geholt, wie das Archiv verbessert werden könnte. Dort entstanden dann gute Ideen, die ich dann auch umgesetzt habe. Das Endergebnis wurde dann in der App getestet und vom gesamten Team als gut befunden.

===== Bewertung und Lernerfahrungen
Bei dieser Aufgabe wurde mir bewusst, wie wichtig Feedback ist, welches von Nutzern der App kommt. Diese kennen nämlich die Architektur hinter der App nicht und fokussieren sich lediglich auf die Anforderungen bzw. ihre Wünsche. Somit entstand nämlich eine Idee der Filterfunktion welche grundlegend einen anderen Ansatz verfolgte. Daraus resultierte ein Ergebnis, welches ich selbst aus Nutzersicht besser fand, aber aus Entwicklersicht garnicht so betrachtet hatte.


=== Erik Wenke

Im Rückblick auf den Verlauf des zweiten Teiles von Software Engineering
habe ich hauptsächlich an zwei Features/Anforderungen gearbeitet.
Einmal galt es, zusätzlich zur schon vorhandenen manuellen Installation,
eine weitere Deployment-Strategie mittels Docker zu entwickeln.
Zudem habe ich Zeit dafür investiert,
die UI für die Favoriten zu implementieren.
Die Favoriten kann man sich dabei als Templates für häufig gekaufte Produkte vorstellen.

==== Docker

Der zentrale Aufwand bei der Entwicklung der Strategie lag im Aneignen von Wissen.
Docker war für mich ein neues Tool.
Zudem hatten wir in der bisherigen Entwicklung wenige Gedanken im Hinblick auf
Deployment-Strategien investiert.
Um einen Einblick in Docker zu bekommen und meinen Lernprozess anzustoßen,
hatte sich gut das angebotene Praktikum geeignet.
Bei allen weiteren Fragen konnte mir die link:https://docs.docker.com/[Docker Dokumentation]
oder spezifische Anleitungen
(z.B. link:https://docs.docker.com/guides/vuejs/containerize/[Vue.js]) helfen.

Währender der Umsetzung ist uns aufgefallen,
dass wir bis jetzt die URL der von uns bereitgestellten API
direkt in den Frontendquelltext geschrieben haben.

[source,JavaScript]
----
const response = await axios.get(`http://141.56.137.83:8000/einheiten`);
----

Diese müssten bei einer Installation ausgetauscht werden,
wenn man die API und Datenbank selber hosten möchte.
Das Erstellen einer Axios Instanz mit einer Konfiguration,
welche die Basis URL als Umgebungsvariable bekommt,
löste das Problem.

Mit der Umgebungsvariable ensteht aber ein weiteres Problem.
Das Frontend-Building-Tool link:https://vite.dev/[Vite] benötigt die Umgebungsvariable
zur Build-Zeit.
Dies verhindert, dass man ein Docker Image erstellen kann,
welchem erst zur Laufzeit die Basis URL übergeben bekommt.
Da wir bis zum aktuellen Stand noch keine Lösung gefunden haben,
muss man sich das Docker Image selber compilieren,
auch wenn es "wahrscheinlich" eine Lösung gibt.

Die Beschreibung des Docker Images für die API hat ohne Zwischenfälle funktioniert.
Hier wurde nur hinzugefügt,
dass die mit der API verbundene Datenbank noch nicht verhandene,
aber in der SQLAlchemy MetaData beschriebene,
Tabellen direkt erstellen soll.
So muss das Datenmodell nicht zusätzlich durch ein SQL-Skript beschrieben werden.
Eine Beispiel-Installation der gesamten Anwendung auf einem System
ist über einem Docker Compose File realisiert.

Damit ergänzt die entwickelte Deployment-Strategie,
die manuelle Installation des Systems.
Auch wenn Sie aufgrund der momentanen Notwendigkeit die Docker Images selber zu bauen,
noch nicht diese abgelöst hat.
Im Rückblick freue ich mich darüber, die Möglichkeit bekommen zu haben,
mich mehr mit Docker auseinandersetzen zu können.
Ich würde behaupten, dass ich einen guten Einblick in Docker bekommen habe,
auch wenn mir im Moment noch ein bisschen der Überblick fehlt,
um die Gesamtheit und Sinnigkeit von Docker als Tool einzuschätzen.
Gerade in der Abtrennung von anderen Möglichkeiten wie z.B. link:https://nixos.org/[Nix]
fehlt mir noch ein bisschen die Übersicht,
um eine fundierte und disskursfähige Meinung zu entwickeln.
Auch stört es mich, dass bis jetzt keien Lösung für das Vite-Build-Problem gefunden wurde.

==== Favoriten

Bevor ich die UI implementierte, waren mir schon zwei Sachen im Kopf.
Erstens sollten die einzelnen Komponenten übersichtliche sein,
um zu verhindern, dass wir eine weitere Komponente erstellen,
welche 900+ Zeilen Quelltext beinhaltete (siehe List.vue).
Zudem war ein weiteres Ziel, bei der Erstellung des UI mehrere wieder verwendbare
Komponenten wie zum Beispiel Input Felder zu erstellen.

Die Herausforderung war,
dass je kleinteiliger ich die Komponenten voneinander trenne,
desto mehr Gedanken muss ich mir über die Kommunikation dieser miteinander machen.
Möchte ich zum Beispiel ein allgemeines SingleChoice-Feld erstellen,
dann muss sein interner Zustand abgekoppelt von dem der Elternkomponente sein.
So mussen Funktionalitäten wie Auswahlmöglichkeiten und Standardwert übergeben
und deren Veränderung kommuniziert werden.

Eine Lösung war die Favoriten über globales Prop-Drilling,
allen Kind Komponenten der App-Komponente als reaktive Variable zur Verfügung zu stellen.

[source,JavaScript]
----
// App.vue
const favorites = ref([]);
provide("favorites", favorites);

// Favorites.vue
inject("favorites");
----

Somit können alle Komponenten die Favoriten bearbeiten
und teilen einen gemeinsamen Zustand der Favoriten.

Neben den von mir entwickelten Input Feldern,
könnte ich auch auf bereits implementierte Komponenten zurückgreifen.
Die Komponente, welche die Produkte in den Einkauflisten als Karte darstellt,
konnte ich auch hier nutzen,
da auch die Favoriten als Gitter dargestellt werden sollten.

Abschießend sehe ich auf die Implementierung des UI eher kritisch.
Die von mir entwickelten allgemeinen Komponenten (NumInput, TextInput, SelectObjectArray)
wurden nicht nochmal an anderer Stelle eingebunden.
Der Grund dafür ist einfach. Es gibt Component-Libraries.
Diese hatten wir nicht von Anfang an bei der Entwicklung unseres UI bedacht.
Ein klassiches Ziel für ein zukünftiges umfangreiches Refactoring.
Generell würde ich bei einer Überarbeitung des gesamten Projektes gerne
weitere Frameworks und Tools einbinden
(z.B. link:https://nuxt.com/[Nuxt] oder link:https://tailwindcss.com/[Tailwind CSS]),
um Funktionalitäten aus- und zuverlagern.
Auch würde ich mich bei einer Überarbeitung für einen Store (z.B. link:https://pinia.vuejs.org/[Pinia])
anstatt des Prop-Drillings entscheiden,
um den Anwendungszustand zu verwalten.

Diese Verbesserungsmöglichkeiten sind jedoch nicht nur negativ zu sehen.
Durch verschiedene andere Module ist der Umfang meines/unseres Wissens
dieses Semester stark gestiegen und unterscheidet sich deutlich von dem,
was zum Anfang des Semesters vorhanden war.
Die Implementierung nur auf HTML, CSS und JavaScript
(im Rahmen des Vue Frameworks) aufzubauen,
würde ich schlussendlich als gute Erfahrung einschätzen.

<<<

=== Eric Hübel

Meine Rolle im Team 4B war Entwickler mit Fokus auf Frontend und Design, das Reviewen von Pull Requests und die Entwicklerdokumentation. Also Implementierung, Code Review und Dokumentation. Ich war sehr motiviert, da ich sofort gemerkt habe, dass das Team wirklich Lust auf das Projekt hatte im Gegensatz zu meinem alten Team, welches immer so schnell wie möglich mit allem fertig werden wollte. Außerdem hatte ich persönliches Interesse am Projekt, da ich gerne Einkaufen gehe und das Listenschreiben manchmal nervig ist.

==== Designinkonsistenzen (link:https://github.com/Pierro-e/HTWD-SE-shareshop_4B/issues/195[Issue 195], link:https://github.com/Pierro-e/HTWD-SE-shareshop_4B/pull/198[PR 198])

Als neues Teammitglied habe ich mir zuerst das Frontend der App angeschaut und mir sind da viele kleine Probleme aufgefallen, wie fehlendes CSS auf Seiten, Rechtschreibfehler und eine schlechte mobile Ansicht. Deshalb wollte ich als meine erste Aufgabe diese technischen Schulden aus dem letzten Semester beseitigen. Es gab nicht wirklich eine User Story zu dem Zeitpunkt dafür, also habe ich ein Issue dazu selber erstellt und alle Probleme als Checkliste aufgeschrieben. Insgesamt hatte ich dann das CSS nochmal gerefactort und vor allem doppeltes CSS entfernt. Zum Beispiel gab es die ProductCard doppelt, da Einkauf.vue einfach eine geänderte Kopie von List.vue war. Die mobile Ansicht war auch sehr wichtig, da es schließlich eine Handyapp werden sollte und es unwahrscheinlich ist, dass man beim Einkaufen einen Laptop mitnimmt.

Dies war wirklich wichtig, da durch den Abbau technischer Schulden das Implementieren zukünftiger Features wie der Light-/Darkmode, deutlich einfacher wurde und man langfristig mehr Lust hat am Frontend weiterzuarbeiten.
Zusätzlich hatte ich erste Erfahrungen mit Pull Requests gemacht und wie man solche erstellt. Ein erster Fallstrick war hier, dass ich vergessen hatte den Base Branch auf den developer-Branch zu stellen, denn standardmäßig nimmt es main.

==== node_modules Ordner (link:https://github.com/Pierro-e/HTWD-SE-shareshop_4B/commit/84cf837e30fde175ef9a43d27221fcda42f41f89[Commit 84cf837])

Neben den Designproblemen war mir auch aufgefallen, dass ein riesiger node_modules Ordner hochgeladen war. Deshalb hatte ich diesen Ordner gelöscht und in die .gitignore gepackt, damit sowas nicht nochmals passiert. Wir haben uns entschlossen dafür keinen PR zu erstellen, da die Änderung ja nur das Löschen des Ordners war und keiner den braucht. Das war ein wichtiger Schritt, da es mein VS Code sonst die ganze Zeit sehr langsam wäre, da es versuchte alle möglichen Dateien in dem riesigen Ordner zu parsen.

==== Ansichtseinstellungen (link:https://github.com/Pierro-e/HTWD-SE-shareshop_4B/issues/199[Issue 199], link:https://github.com/Pierro-e/HTWD-SE-shareshop_4B/pull/233[PR 233])

Ich hatte in meiner zweiten Aufgabe auch angefangen die Änderungen in einem PR besser zu beschreiben und gleich den Issue zu verlinken, damit klarer ist um welche Aufgabe es sich gehandelt hatte. Bei Scrum-Praktiken geht es eher darum keine Extra-Features mit einzubauen, die nicht Teil der Aufgabe waren, aber ich hatte trotzdem zusätzlich Verbesserungen und Bugfixes mit drinnen. Wir haben aber im Team gemerkt, dass es manchmal einfacher ist nicht wegen jeder Kleinigkeit einen neuen Branch und PR erstellen zu müssen.

==== Dropdown mit Favoriten (link:https://github.com/Pierro-e/HTWD-SE-shareshop_4B/issues/226[Issue 226], link:https://github.com/Pierro-e/HTWD-SE-shareshop_4B/issues/227[227], link:https://github.com/Pierro-e/HTWD-SE-shareshop_4B/issues/228[228]; link:https://github.com/Pierro-e/HTWD-SE-shareshop_4B/pull/271[PR 271])

Eine schwierigere Aufgabe war ein Dropdown mit Favoriten zu erstellen. Denn um Favoriten im Dropdown anzuzeigen, war es nötig Favoriten für einen Nutzer zu erstellen. Leider hat es 4 Wochen gedauert auf die Favoritenkomponente des anderen Teammitglieds zu warten. Es wäre theoretisch auch möglich die Favoriten über die API zu erstellen, nur ist das umständlich und fehleranfällig. Es hat solange gedauert, da er viele andere Dinge geändert hat, die nicht Teil der Aufgabe waren. (link:https://github.com/Pierro-e/HTWD-SE-shareshop_4B/pull/302[PR 302]) Ich hatte mich dann mit ihm 3 Std. im Discord hingesetzt und darüber geredet, denn die anderen Änderungen hatten teilweise leider mehr Bugs mit reingebracht. Da ich keine Regression mergen wollte, hatten wir uns schlussendlich aus Zeitgründen dazu entschlossen einen neuen Branch und damit PR zu erstellen. Dort wurden nur die geänderten Dateien zu den Favoriten hinzugefügt. (link:https://github.com/Pierro-e/HTWD-SE-shareshop_4B/pull/311[PR 311]) Damit müssten wir nicht noch jeden Bug fixen, der in den anderen Dateien möglicherweise reingekommen war. Mir fiel die Entscheidung nicht leicht vorzuschlagen, dass wir alles andere, was er erstellt hatte und nicht Teil der Aufgabe war, verwerfen. Aber ich finde es war die beste Lösung, da ich nicht noch länger auf das Feature warten konnte. Auch wenn es oft gut geht, weitere Änderungen neben der Aufgabe vorzunehmen, sieht man an diesem Beispiel, dass es unnötige Verzögerungen dadurch geben kann. Dies ist besonders problematisch bei Aufgaben, die auf einer anderen aufbauen. Deshalb halte ich es für sinnvoll, dass jede Aufgabe unabhängig ist und alle Anforderungen im Voraus fertiggestellt sind.

==== Reviewen von Pull Requests

Eine weitere kontinuierliche Aufgabe war das Reviewen von Pull Requests von Entwicklern im Frontend. Da habe ich immer alles manuell getestet und geschaut ob die Akzeptanzkriterien, welche in den User Stories beschrieben waren, erfüllt wurden. Ich habe oft nicht die Github Features zum Kommentieren genutzt, da die meisten nicht so oft ins Github reinschauen und deshalb schrieb ich die Personen direkt über WhatsApp an. Dies hat eine schnellere Kommunikation ermöglicht, da man hier auch einfacher Screenshots teilen konnte und damit Probleme schneller zeigen konnte. Rückblickend finde ich aber, dass dadurch es zwar kurzfristig effizient war, aber man langfristig nicht mehr weiß worüber man sich unterhalten hatte. Denn wenn man über Github kommuniziert, sind Entscheidungen, Fragen und Probleme auch Jahre später für alle noch sichtbar.

==== Entwicklerdokumentation

Für die Entwicklerdoku mit JSDoc musste ich sie besser für Vue.js integrieren. Dafür musste ich die .vue Dateien zur jsdoc-Config und das Plugin link:https://github.com/Kocal/jsdoc-vuejs[jsdoc-vuejs] hinzufügen, wodurch man props von Methoden besser beschreiben konnte. (link:https://github.com/Pierro-e/HTWD-SE-shareshop_4B/blob/developer/src/frontend/shareshop_4b/jsdoc.json[jsdoc-config]) Da jsdoc die Doku immer als HTML exportiert, musste ich diese noch mit link:https://wkhtmltopdf.org/[wkhtmltopdf] in eine PDF konvertieren. Leider funktionierte das Minami JSDoc-Theme nicht gut damit, denn durch das Menü hat den Text verdeckt. Deshalb musste ich eine weitere Config anlegen, wo ich das Defaulttheme verwende. Ich hatte leider bisher kein besseren Weg gefunden die Dokumentation als PDF zu exportieren. Möglicherweise wäre ein anderes Tool, wie link:https://thejaredwilcurt.com/vue-doxen/[Vue-Doxen] besser, aber da JSDoc vertrauter war nutzen wir das.

==== Fazit

Insgesamt bin ich relativ zufrieden mit dem Endergebnis, denn die App funktioniert und sieht gut aus. Trotzdem hätte man aber noch mehr refactorn und sich an die Coding-Styleguidelines halten müssen. Und wir hätten von Anfang an eine UI-Library wie link:https://vuetifyjs.com[Vuetify] nutzen sollen und nicht alles von Hand erstellen, wodurch wir mehr Zeit für andere Dinge, wie Tests oder das Refactorn haben könnten. Aber immerhin habe ich dadurch viel über CSS lernen können, was man beim bloßen Nutzen von solchen Libraries nicht tut.

=== Ahmad Alrmih

Im zweiten Teil von *Software Engineering 2* habe ich mich hauptsächlich mit der **Implementierung und Absicherung der Backend-Funktionalitäten** der ShareShop-Anwendung beschäftigt. Mein Schwerpunkt lag dabei auf der **Entwicklung von Unit-Tests**, der **Mitarbeit an API-Endpunkten** sowie der **Implementierung von Validierungslogik**.

==== Ausgangssituation und Einordnung in den SE-Prozess

Meine Aufgaben lassen sich vor allem den Phasen **Implementierung** und **Test** zuordnen.  
Konkret habe ich:
* an mehrere **FastAPI-Endpunkten** mitgearbeitet
* **Validierungsfunktionen** für Eingaben entwickelt
* eine **umfassende Suite von Unit-Tests** für die API erstellt

Die getesteten Endpunkte wurden teilweise oder größten teils  von anderen Teammitgliedern entworfen oder implementiert, sodass meine Arbeit direkt auf bestehenden Analyse- und Entwurfsentscheidungen aufbaute.

==== Lösungsweg

Für die Tests habe ich **pytest** in Kombination mit **unittest.mock** verwendet. Ziel war es, die Geschäftslogik der API **isoliert von der Datenbank** zu testen. Dazu habe ich:
* die SQLAlchemy-Session mit `@patch` gemockt
* `MagicMock` genutzt, um verschiedene Datenbank-Szenarien (Erfolg, „nicht gefunden“) zu simulieren
* Hilfsfunktionen erstellt, um Mock-Objekte für Nutzer, Produkte, Listen und weitere Modelle wiederverwendbar zu erzeugen

Die Tests folgen konsequent dem **Arrange–Act–Assert-Prinzip**, was die Lesbarkeit und Wartbarkeit verbessert.  
Zuvor habe ich Validierungsfunktionen entwickelt, um fehlerhafte Eingaben frühzeitig abzufangen und konsistentes Verhalten der Endpunkte sicherzustellen.

==== Bewertung und Lernerfahrungen

Meine Lösung hat gut funktioniert:  
Alle implementierten Tests nun laufen zuverlässig und decken sowohl Erfolgs- als auch Fehlerfälle ab. Dadurch konnten mehrere logische Fehler frühzeitig erkannt werden, ohne die Anwendung manuell testen zu müssen.

Besonders gelernt habe ich:
* wie wichtig **korrektes Mocking** komplexer Datenbank-Abfragen ist
* dass gut geschriebene Tests als **Dokumentation des erwarteten Verhaltens** dienen
* dass Validierung ein zentraler Bestandteil robuster API-Entwicklung ist

Rückblickend sehe ich meinen Beitrag als wertvoll für die **Qualitätssicherung** und **Wartbarkeit** des Projekts. Die enge Verzahnung meiner Arbeit mit den Implementierungen anderer Teammitglieder hat mir zudem geholfen, den gesamten Entwicklungsprozess besser zu verstehen.
