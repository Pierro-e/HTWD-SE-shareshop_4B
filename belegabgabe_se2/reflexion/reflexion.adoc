// Meta
:system-name: ShareShop
// Dokumenten
:doctype: book
:sectnums:
:lang: DE
:experimental:
// Assets
:imageDir: images/
// Inhaltsverzeichnis
:toc:
:toclevels: 2
:toc-title: Inhaltsverzeichnis


= {system-name}: Reflexion
{docdate}

== Gruppenreflexion

=== Misserfolge

==== 1. ...
==== 2. ...
==== 3. ...

=== Erfolge

==== 1. ...
==== 2. ...
==== 3. ...

== Einzelreflexion

=== Maximilian Paul

<<<

=== Pierre Kißling

<<<

=== Marlene Fritz

<<<

=== Levin Heinrich

Ich war im Projekt hauptsächlich für die Implementierung des Backends zuständig. Dabei habe ich mich um die Datenbank gekümmert und die API_Endpunkte, sowie die ORMs für die verschiedenen Modelle erstellt. Zusätzliche habe ich jedoch auch Aufgaben im Frontend übernommen, wie zum Beispiel das Archiv-Feature, aber auch die Mitarbeit an der List- und Einkauf-Komponente.

==== Datenbank
===== Ausgangssituation
Zu Beginn ging es darum eine Struktur zu entwickeln, die es ermöglicht die verschiedenen Entitäten und deren Beziehnungen (die durch die Planung der APP entstanden sind) in einer Datenbank abbilden zu können. Im Laufe des Projekts musste diese Struktur dann angepasst oder um neue Tabellen ergänzt werden. Ich ordne diese Aufgabe in die Analyse- Entwurf- und Implementierungsphase ein.

===== Lösungsweg
Als die Datenbank erstellt bzw. erweiter werden musste begann ich mit einer grafischen Abbildung der Tabellen un deren Beziehungen. Sommit konnte ich mir einen Überblick über die geplante Struktur verschaffen und ggf. Fehler frühzeitig vor der Umsetzung erkennen. Zudem mussten die Werte, die gespeichert werden sollten, vorher klar im Zweck definiert werden, um eine Aussage über den Datentyp treffen zu können. Nachdem die Struktur stand, habe ich die Tabellen in MySQL erstellt und dort einmal getestet, um zu prüfen ob Foreign Keys und andere Einschränkungen wie NULL/NOT NULL richtig funktionierten.  

===== Bewertung und Lernerfahrungen
Rückblickend mkann ich sagen, dass mein Vorgehen grundätzlich gut funktioniert hat. Die grafische Abbildung (auch wenn es nur eine grobe Skizze war) hat besonders am Anfang beim verstehen geholfen. Nahezu am Ende des Projekts habe ich festgestellt dass ich mir jedoch Zeit hätte sparen können, wenn ich die Tabellen direkt in SQLAlchemy erstellt hätte. Da ich mich zu Beginn des Projekts noch nicht so gut mit dem ORM auskannte, habe ich mich für den "sicheren" Weg entschieden. Dies hat zwar funktioniert, aber im Nachhinein gesehen war es unnötig aufwendig.

==== API
===== Ausgangssituation
Bereitstellen der API-Endpunkte für das Frontend. Dabei ging es darum die verschiedenen Funktionalitäten, die im Frontend benötigt werden, über Endpunkte verfügbar zu machen. Ich ordne diese Aufgabe in die Implementierungs- und Testphase ein.

===== Lösungsweg
Da ich immer vorher die Datenbankstruktur erstellte, hatte ich bereits ein gutes Verständnis über die Entitäten und deren Beziehungen. Die Erstellung der ORMs in SQLAlchemy war somit relativ einfach. Anschließend habe ich die Endpunkte (read, create, update, delete) für die verschiedenen Modelle erstellt. Dabei stand ich meistens immer im Austausch mit der Person, die das Frontend dazu entwickelte, um sicherzustellen, dass die Endpunkte auch alle benötigten Funktionalitäten abdecken. Dabei musste ich auch immer überlegen, was man am besten im Backend erledigt und was im Frontend. Wenn ich die Endpunkte erstellt hatte, habe ich diese meist mit der Swagger-UI getestet (weil der Großteil der Arbeit im 1. Semester bzw. am Anfang vom 2. Semester stattfand). In den meisten Fällen mussten dann noch ein paar Anpassungen vorgenommen werden.

===== Bewertung und Lernerfahrungen
Was positiv war, die Kommunikation mit dem Frontend-Team. Diese Kommunikation war auch nötig, da mann sicherstellen musste, dass beide Seiten (Frontend/Backend) die gleichen Vorstellungen von der Funktionalität haben. Nachteilig war, dass ich mir am Anfang etwas unsicher war, welche Berechnungen/Konvertierungen/Validierungen im Backend oder im Frontend gemacht werde sollten. Das wurde mit der Zeit klarer und die Qualität der API-Endpunkte wurde somit auch besser.  

==== Archiv-Feature (Frontend)
===== Ausgangssituation
Das Archiv-Feature ermöglicht es dem Nutzer abgeschlossene Einkäufe, mit allesn Produkten die in diesem Einkauf eingekauft wurden,  im nachhinein anzusehen. Im Archiv kann man nach den einzelnen Listen filtern sowie nur Einkäufe anzeigen lassen die von mir selbst getätig wurden. Ich ordne diese Aufgabe in die Implementierungs- und Testphase ein.

===== Lösungsweg
Zuerst habe ich mir überlegt wie das UI ausehen soll und welche Funktionalitäten es bieten soll. Anschließend habe ich die API-Endpunkte erstellt, die benötigt werden. Danach habe ich das Frontend entwickelt. Das Ergebnis habe ich dann im Team vorgestellt und Feedback eingeholt. Da ich selbst als auch das Team mit dem Ergebnis mittelmäßig zufrieden waren haben wir uns im Review mit den anderen Projektgruppen ausgetauscht und ich habe mir Anregungen geholt, wie das Archiv verbessert werden könnte. Dort entstanden dann gute Ideen, die ich dann auch umgesetzt habe. Das Endergebnis wurde dann in der App getestet und vom gesamten Team als gut befunden.

===== Bewertung und Lernerfahrungen
Bei dieser Aufgabe wurde mir bewusst, wie wichtig Feedback ist, welches von Nutzern der App kommt. Diese kennen nämlich die Architektur hinter der App nicht und fokussieren sich lediglich auf die Anforderungen bzw. ihre Wünsche. Somit entstand nämlich eine Idee der Filterfunktion welche grundlegend einen anderen Ansatz verfolgte. Daraus resultierte ein Ergebnis, welches ich selbst aus Nutzersicht besser fand, aber aus Entwicklersicht garnicht so betrachtet hatte.


=== Erik Wenke

Im Rückblick auf den Verlauf des zweiten Teiles von Software Engineering
habe ich hauptsächlich an zwei Features/Anforderungen gearbeitet.
Einmal galt es, zusätzlich zur schon vorhandenen manuellen Installation,
eine weitere Deployment-Strategie mittels Docker zu entwickeln.
Zudem habe ich Zeit dafür investiert,
die UI für die Favoriten zu implementieren.
Die Favoriten kann man sich dabei als Templates für häufig gekaufte Produkte vorstellen.

==== Docker

Der zentrale Aufwand bei der Entwicklung der Strategie lag im Aneignen von Wissen.
Docker war für mich ein neues Tool.
Zudem hatten wir in der bisherigen Entwicklung wenige Gedanken im Hinblick auf
Deployment-Strategien investiert.
Um einen Einblick in Docker zu bekommen und meinen Lernprozess anzustoßen,
hatte sich gut das angebotene Praktikum geeignet.
Bei allen weiteren Fragen konnte mir die link:https://docs.docker.com/[Docker Dokumentation]
oder spezifische Anleitungen
(z.B. link:https://docs.docker.com/guides/vuejs/containerize/[Vue.js]) helfen.

Währender der Umsetzung ist uns aufgefallen,
dass wir bis jetzt die URL der von uns bereitgestellten API
direkt in den Frontendquelltext geschrieben haben.

[source,JavaScript]
----
const response = await axios.get(`http://141.56.137.83:8000/einheiten`);
----

Diese müssten bei einer Installation ausgetauscht werden,
wenn man die API und Datenbank selber hosten möchte.
Das Erstellen einer Axios Instanz mit einer Konfiguration,
welche die Basis URL als Umgebungsvariable bekommt,
löste das Problem.

Mit der Umgebungsvariable ensteht aber ein weiteres Problem.
Das Frontend-Building-Tool link:https://vite.dev/[Vite] benötigt die Umgebungsvariable
zur Build-Zeit.
Dies verhindert, dass man ein Docker Image erstellen kann,
welchem erst zur Laufzeit die Basis URL übergeben bekommt.
Da wir bis zum aktuellen Stand noch keine Lösung gefunden haben,
muss man sich das Docker Image selber compilieren,
auch wenn es "wahrscheinlich" eine Lösung gibt.

Die Beschreibung des Docker Images für die API hat ohne Zwischenfälle funktioniert.
Hier wurde nur hinzugefügt,
dass die mit der API verbundene Datenbank noch nicht verhandene,
aber in der SQLAlchemy MetaData beschriebene,
Tabellen direkt erstellen soll.
So muss das Datenmodell nicht zusätzlich durch ein SQL-Skript beschrieben werden.
Eine Beispiel-Installation der gesamten Anwendung auf einem System
ist über einem Docker Compose File realisiert.

Damit ergänzt die entwickelte Deployment-Strategie,
die manuelle Installation des Systems.
Auch wenn Sie aufgrund der momentanen Notwendigkeit die Docker Images selber zu bauen,
noch nicht diese abgelöst hat.
Im Rückblick freue ich mich darüber, die Möglichkeit bekommen zu haben,
mich mehr mit Docker auseinandersetzen zu können.
Ich würde behaupten, dass ich einen guten Einblick in Docker bekommen habe,
auch wenn mir im Moment noch ein bisschen der Überblick fehlt,
um die Gesamtheit und Sinnigkeit von Docker als Tool einzuschätzen.
Gerade in der Abtrennung von anderen Möglichkeiten wie z.B. link:https://nixos.org/[Nix]
fehlt mir noch ein bisschen die Übersicht,
um eine fundierte und disskursfähige Meinung zu entwickeln.
Auch stört es mich, dass bis jetzt keien Lösung für das Vite-Build-Problem gefunden wurde.

==== Favoriten

Bevor ich die UI implementierte, waren mir schon zwei Sachen im Kopf.
Erstens sollten die einzelnen Komponenten übersichtliche sein,
um zu verhindern, dass wir eine weitere Komponente erstellen,
welche 900+ Zeilen Quelltext beinhaltete (siehe List.vue).
Zudem war ein weiteres Ziel, bei der Erstellung des UI mehrere wieder verwendbare
Komponenten wie zum Beispiel Input Felder zu erstellen.

Die Herausforderung war,
dass je kleinteiliger ich die Komponenten voneinander trenne,
desto mehr Gedanken muss ich mir über die Kommunikation dieser miteinander machen.
Möchte ich zum Beispiel ein allgemeines SingleChoice-Feld erstellen,
dann muss sein interner Zustand abgekoppelt von dem der Elternkomponente sein.
So mussen Funktionalitäten wie Auswahlmöglichkeiten und Standardwert übergeben
und deren Veränderung kommuniziert werden.

Eine Lösung war die Favoriten über globales Prop-Drilling,
allen Kind Komponenten der App-Komponente als reaktive Variable zur Verfügung zu stellen.

[source,JavaScript]
----
// App.vue
const favorites = ref([]);
provide("favorites", favorites);

// Favorites.vue
inject("favorites");
----

Somit können alle Komponenten die Favoriten bearbeiten
und teilen einen gemeinsamen Zustand der Favoriten.

Neben den von mir entwickelten Input Feldern,
könnte ich auch auf bereits implementierte Komponenten zurückgreifen.
Die Komponente, welche die Produkte in den Einkauflisten als Karte darstellt,
konnte ich auch hier nutzen,
da auch die Favoriten als Gitter dargestellt werden sollten.

Abschießend sehe ich auf die Implementierung des UI eher kritisch.
Die von mir entwickelten allgemeinen Komponenten (NumInput, TextInput, SelectObjectArray)
wurden nicht nochmal an anderer Stelle eingebunden.
Der Grund dafür ist einfach. Es gibt Component-Libraries.
Diese hatten wir nicht von Anfang an bei der Entwicklung unseres UI bedacht.
Ein klassiches Ziel für ein zukünftiges umfangreiches Refactoring.
Generell würde ich bei einer Überarbeitung des gesamten Projektes gerne
weitere Frameworks und Tools einbinden
(z.B. link:https://nuxt.com/[Nuxt] oder link:https://tailwindcss.com/[Tailwind CSS]),
um Funktionalitäten aus- und zuverlagern.
Auch würde ich mich bei einer Überarbeitung für einen Store (z.B. link:https://pinia.vuejs.org/[Pinia])
anstatt des Prop-Drillings entscheiden,
um den Anwendungszustand zu verwalten.

Diese Verbesserungsmöglichkeiten sind jedoch nicht nur negativ zu sehen.
Durch verschiedene andere Module ist der Umfang meines/unseres Wissens
dieses Semester stark gestiegen und unterscheidet sich deutlich von dem,
was zum Anfang des Semesters vorhanden war.
Die Implementierung nur auf HTML, CSS und JavaScript
(im Rahmen des Vue Frameworks) aufzubauen,
würde ich schlussendlich als gute Erfahrung einschätzen.

<<<

=== Eric Hübel

<<<

=== Ahmad Alrmih

Im zweiten Teil von *Software Engineering 2* habe ich mich hauptsächlich mit der **Implementierung und Absicherung der Backend-Funktionalitäten** der ShareShop-Anwendung beschäftigt. Mein Schwerpunkt lag dabei auf der **Entwicklung von Unit-Tests**, der **Mitarbeit an API-Endpunkten** sowie der **Implementierung von Validierungslogik**.

==== Ausgangssituation und Einordnung in den SE-Prozess

Meine Aufgaben lassen sich vor allem den Phasen **Implementierung** und **Test** zuordnen.  
Konkret habe ich:
* an mehrere **FastAPI-Endpunkten** mitgearbeitet
* **Validierungsfunktionen** für Eingaben entwickelt
* eine **umfassende Suite von Unit-Tests** für die API erstellt

Die getesteten Endpunkte wurden teilweise oder größten teils  von anderen Teammitgliedern entworfen oder implementiert, sodass meine Arbeit direkt auf bestehenden Analyse- und Entwurfsentscheidungen aufbaute.

==== Lösungsweg

Für die Tests habe ich **pytest** in Kombination mit **unittest.mock** verwendet. Ziel war es, die Geschäftslogik der API **isoliert von der Datenbank** zu testen. Dazu habe ich:
* die SQLAlchemy-Session mit `@patch` gemockt
* `MagicMock` genutzt, um verschiedene Datenbank-Szenarien (Erfolg, „nicht gefunden“) zu simulieren
* Hilfsfunktionen erstellt, um Mock-Objekte für Nutzer, Produkte, Listen und weitere Modelle wiederverwendbar zu erzeugen

Die Tests folgen konsequent dem **Arrange–Act–Assert-Prinzip**, was die Lesbarkeit und Wartbarkeit verbessert.  
Zuvor habe ich Validierungsfunktionen entwickelt, um fehlerhafte Eingaben frühzeitig abzufangen und konsistentes Verhalten der Endpunkte sicherzustellen.

==== Bewertung und Lernerfahrungen

Meine Lösung hat gut funktioniert:  
Alle implementierten Tests nun laufen zuverlässig und decken sowohl Erfolgs- als auch Fehlerfälle ab. Dadurch konnten mehrere logische Fehler frühzeitig erkannt werden, ohne die Anwendung manuell testen zu müssen.

Besonders gelernt habe ich:
* wie wichtig **korrektes Mocking** komplexer Datenbank-Abfragen ist
* dass gut geschriebene Tests als **Dokumentation des erwarteten Verhaltens** dienen
* dass Validierung ein zentraler Bestandteil robuster API-Entwicklung ist

Rückblickend sehe ich meinen Beitrag als wertvoll für die **Qualitätssicherung** und **Wartbarkeit** des Projekts. Die enge Verzahnung meiner Arbeit mit den Implementierungen anderer Teammitglieder hat mir zudem geholfen, den gesamten Entwicklungsprozess besser zu verstehen.
